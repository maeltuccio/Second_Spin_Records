// bottleneck@2.19.5 downloaded from https://ga.jspm.io/npm:bottleneck@2.19.5/lib/index.js

var exports={},_dewExec=false;function dew(){if(_dewExec)return exports;_dewExec=true;exports.load=function(e,t,n={}){var r,i,s;for(r in t){s=t[r];n[r]=null!=(i=e[r])?i:s}return n};exports.overwrite=function(e,t,n={}){var r,i;for(r in e){i=e[r];void 0!==t[r]&&(n[r]=i)}return n};return exports}var exports$1={},_dewExec$1=false;function dew$1(){if(_dewExec$1)return exports$1;_dewExec$1=true;var e;e=class DLList{constructor(e,t){this.incr=e;this.decr=t;this._first=null;this._last=null;this.length=0}push(e){var t;this.length++;"function"===typeof this.incr&&this.incr();t={value:e,prev:this._last,next:null};if(null!=this._last){this._last.next=t;this._last=t}else this._first=this._last=t}shift(){var e;if(null!=this._first){this.length--;"function"===typeof this.decr&&this.decr();e=this._first.value;null!=(this._first=this._first.next)?this._first.prev=null:this._last=null;return e}}first(){if(null!=this._first)return this._first.value}getArray(){var e,t,n;e=this._first;n=[];while(null!=e)n.push((t=e,e=e.next,t.value));return n}forEachShift(e){var t;t=this.shift();while(null!=t)e(t),t=this.shift()}debug(){var e,t,n,r,i;e=this._first;i=[];while(null!=e)i.push((t=e,e=e.next,{value:t.value,prev:null!=(n=t.prev)?n.value:void 0,next:null!=(r=t.next)?r.value:void 0}));return i}};exports$1=e;return exports$1}var exports$2={},_dewExec$2=false;function dew$2(){if(_dewExec$2)return exports$2;_dewExec$2=true;function asyncGeneratorStep(e,t,n,r,i,s,o){try{var a=e[s](o);var l=a.value}catch(e){n(e);return}a.done?t(l):Promise.resolve(l).then(r,i)}function _asyncToGenerator(e){return function(){var t=this,n=arguments;return new Promise((function(r,i){var s=e.apply(t,n);function _next(e){asyncGeneratorStep(s,r,i,_next,_throw,"next",e)}function _throw(e){asyncGeneratorStep(s,r,i,_next,_throw,"throw",e)}_next(void 0)}))}}var e;e=class Events{constructor(e){this.instance=e;this._events={};if(null!=this.instance.on||null!=this.instance.once||null!=this.instance.removeAllListeners)throw new Error("An Emitter already exists for this object");this.instance.on=(e,t)=>this._addListener(e,"many",t);this.instance.once=(e,t)=>this._addListener(e,"once",t);this.instance.removeAllListeners=(e=null)=>null!=e?delete this._events[e]:this._events={}}_addListener(e,t,n){var r;null==(r=this._events)[e]&&(r[e]=[]);this._events[e].push({cb:n,status:t});return this.instance}listenerCount(e){return null!=this._events[e]?this._events[e].length:0}trigger(e,...t){var n=this;return _asyncToGenerator((function*(){var r,i;try{"debug"!==e&&n.trigger("debug",`Event triggered: ${e}`,t);if(null==n._events[e])return;n._events[e]=n._events[e].filter((function(e){return"none"!==e.status}));i=n._events[e].map(function(){var e=_asyncToGenerator((function*(e){var r,i;if("none"!==e.status){"once"===e.status&&(e.status="none");try{i="function"===typeof e.cb?e.cb(...t):void 0;return"function"===typeof(null!=i?i.then:void 0)?yield i:i}catch(e){r=e;"name"!=="error"&&n.trigger("error",r);return null}}}));return function(t){return e.apply(this,arguments)}}());return(yield Promise.all(i)).find((function(e){return null!=e}))}catch(e){r=e;"name"!=="error"&&n.trigger("error",r);return null}}))()}};exports$2=e;return exports$2}var exports$3={},_dewExec$3=false;function dew$3(){if(_dewExec$3)return exports$3;_dewExec$3=true;var e,t,n;e=dew$1();t=dew$2();n=class Queues{constructor(n){var r;this.Events=new t(this);this._length=0;this._lists=function(){var t,i,s;s=[];for(r=t=1,i=n;1<=i?t<=i:t>=i;r=1<=i?++t:--t)s.push(new e(()=>this.incr(),()=>this.decr()));return s}.call(this)}incr(){if(0===this._length++)return this.Events.trigger("leftzero")}decr(){if(0===--this._length)return this.Events.trigger("zero")}push(e){return this._lists[e.options.priority].push(e)}queued(e){return null!=e?this._lists[e].length:this._length}shiftAll(e){return this._lists.forEach((function(t){return t.forEachShift(e)}))}getFirst(e=this._lists){var t,n,r;for(t=0,n=e.length;t<n;t++){r=e[t];if(r.length>0)return r}return[]}shiftLastFrom(e){return this.getFirst(this._lists.slice(e).reverse()).shift()}};exports$3=n;return exports$3}var exports$4={},_dewExec$4=false;function dew$4(){if(_dewExec$4)return exports$4;_dewExec$4=true;var e;e=class BottleneckError extends Error{};exports$4=e;return exports$4}var exports$5={},_dewExec$5=false;function dew$5(){if(_dewExec$5)return exports$5;_dewExec$5=true;function asyncGeneratorStep(e,t,n,r,i,s,o){try{var a=e[s](o);var l=a.value}catch(e){n(e);return}a.done?t(l):Promise.resolve(l).then(r,i)}function _asyncToGenerator(e){return function(){var t=this,n=arguments;return new Promise((function(r,i){var s=e.apply(t,n);function _next(e){asyncGeneratorStep(s,r,i,_next,_throw,"next",e)}function _throw(e){asyncGeneratorStep(s,r,i,_next,_throw,"throw",e)}_next(void 0)}))}}var e,t,n,r,i;r=10;t=5;i=dew();e=dew$4();n=class Job{constructor(e,t,n,r,s,o,a,l){this.task=e;this.args=t;this.rejectOnDrop=s;this.Events=o;this._states=a;this.Promise=l;this.options=i.load(n,r);this.options.priority=this._sanitizePriority(this.options.priority);this.options.id===r.id&&(this.options.id=`${this.options.id}-${this._randomIndex()}`);this.promise=new this.Promise((e,t)=>{this._resolve=e;this._reject=t});this.retryCount=0}_sanitizePriority(e){var n;n=~~e!==e?t:e;return n<0?0:n>r-1?r-1:n}_randomIndex(){return Math.random().toString(36).slice(2)}doDrop({error:t,message:n="This job has been dropped by Bottleneck"}={}){if(this._states.remove(this.options.id)){this.rejectOnDrop&&this._reject(null!=t?t:new e(n));this.Events.trigger("dropped",{args:this.args,options:this.options,task:this.task,promise:this.promise});return true}return false}_assertStatus(t){var n;n=this._states.jobStatus(this.options.id);if(!(n===t||"DONE"===t&&null===n))throw new e(`Invalid job status ${n}, expected ${t}. Please open an issue at https://github.com/SGrondin/bottleneck/issues`)}doReceive(){this._states.start(this.options.id);return this.Events.trigger("received",{args:this.args,options:this.options})}doQueue(e,t){this._assertStatus("RECEIVED");this._states.next(this.options.id);return this.Events.trigger("queued",{args:this.args,options:this.options,reachedHWM:e,blocked:t})}doRun(){if(0===this.retryCount){this._assertStatus("QUEUED");this._states.next(this.options.id)}else this._assertStatus("EXECUTING");return this.Events.trigger("scheduled",{args:this.args,options:this.options})}doExecute(e,t,n,r){var i=this;return _asyncToGenerator((function*(){var s,o,a;if(0===i.retryCount){i._assertStatus("RUNNING");i._states.next(i.options.id)}else i._assertStatus("EXECUTING");o={args:i.args,options:i.options,retryCount:i.retryCount};i.Events.trigger("executing",o);try{a=yield null!=e?e.schedule(i.options,i.task,...i.args):i.task(...i.args);if(t()){i.doDone(o);yield r(i.options,o);i._assertStatus("DONE");return i._resolve(a)}}catch(e){s=e;return i._onFailure(s,o,t,n,r)}}))()}doExpire(t,n,r){var i,s;this._states.jobStatus("RUNNING"===this.options.id)&&this._states.next(this.options.id);this._assertStatus("EXECUTING");s={args:this.args,options:this.options,retryCount:this.retryCount};i=new e(`This job timed out after ${this.options.expiration} ms.`);return this._onFailure(i,s,t,n,r)}_onFailure(e,t,n,r,i){var s=this;return _asyncToGenerator((function*(){var o,a;if(n()){o=yield s.Events.trigger("failed",e,t);if(null!=o){a=~~o;s.Events.trigger("retry",`Retrying ${s.options.id} after ${a} ms`,t);s.retryCount++;return r(a)}s.doDone(t);yield i(s.options,t);s._assertStatus("DONE");return s._reject(e)}}))()}doDone(e){this._assertStatus("EXECUTING");this._states.next(this.options.id);return this.Events.trigger("done",e)}};exports$5=n;return exports$5}var exports$6={},_dewExec$6=false;function dew$6(){if(_dewExec$6)return exports$6;_dewExec$6=true;function asyncGeneratorStep(e,t,n,r,i,s,o){try{var a=e[s](o);var l=a.value}catch(e){n(e);return}a.done?t(l):Promise.resolve(l).then(r,i)}function _asyncToGenerator(e){return function(){var t=this,n=arguments;return new Promise((function(r,i){var s=e.apply(t,n);function _next(e){asyncGeneratorStep(s,r,i,_next,_throw,"next",e)}function _throw(e){asyncGeneratorStep(s,r,i,_next,_throw,"throw",e)}_next(void 0)}))}}var e,t,n;n=dew();e=dew$4();t=class LocalDatastore{constructor(e,t,r){this.instance=e;this.storeOptions=t;this.clientId=this.instance._randomIndex();n.load(r,r,this);this._nextRequest=this._lastReservoirRefresh=this._lastReservoirIncrease=Date.now();this._running=0;this._done=0;this._unblockTime=0;this.ready=this.Promise.resolve();this.clients={};this._startHeartbeat()}_startHeartbeat(){var e;return null==this.heartbeat&&(null!=this.storeOptions.reservoirRefreshInterval&&null!=this.storeOptions.reservoirRefreshAmount||null!=this.storeOptions.reservoirIncreaseInterval&&null!=this.storeOptions.reservoirIncreaseAmount)?"function"===typeof(e=this.heartbeat=setInterval(()=>{var e,t,n,r,i;r=Date.now();if(null!=this.storeOptions.reservoirRefreshInterval&&r>=this._lastReservoirRefresh+this.storeOptions.reservoirRefreshInterval){this._lastReservoirRefresh=r;this.storeOptions.reservoir=this.storeOptions.reservoirRefreshAmount;this.instance._drainAll(this.computeCapacity())}if(null!=this.storeOptions.reservoirIncreaseInterval&&r>=this._lastReservoirIncrease+this.storeOptions.reservoirIncreaseInterval){var s=this.storeOptions;e=s.reservoirIncreaseAmount;n=s.reservoirIncreaseMaximum;i=s.reservoir;this._lastReservoirIncrease=r;t=null!=n?Math.min(e,n-i):e;if(t>0){this.storeOptions.reservoir+=t;return this.instance._drainAll(this.computeCapacity())}}},this.heartbeatInterval)).unref?e.unref():void 0:clearInterval(this.heartbeat)}__publish__(e){var t=this;return _asyncToGenerator((function*(){yield t.yieldLoop();return t.instance.Events.trigger("message",e.toString())}))()}__disconnect__(e){var t=this;return _asyncToGenerator((function*(){yield t.yieldLoop();clearInterval(t.heartbeat);return t.Promise.resolve()}))()}yieldLoop(e=0){return new this.Promise((function(t,n){return setTimeout(t,e)}))}computePenalty(){var e;return null!=(e=this.storeOptions.penalty)?e:15*this.storeOptions.minTime||5e3}__updateSettings__(e){var t=this;return _asyncToGenerator((function*(){yield t.yieldLoop();n.overwrite(e,e,t.storeOptions);t._startHeartbeat();t.instance._drainAll(t.computeCapacity());return true}))()}__running__(){var e=this;return _asyncToGenerator((function*(){yield e.yieldLoop();return e._running}))()}__queued__(){var e=this;return _asyncToGenerator((function*(){yield e.yieldLoop();return e.instance.queued()}))()}__done__(){var e=this;return _asyncToGenerator((function*(){yield e.yieldLoop();return e._done}))()}__groupCheck__(e){var t=this;return _asyncToGenerator((function*(){yield t.yieldLoop();return t._nextRequest+t.timeout<e}))()}computeCapacity(){var e,t;var n=this.storeOptions;e=n.maxConcurrent;t=n.reservoir;return null!=e&&null!=t?Math.min(e-this._running,t):null!=e?e-this._running:null!=t?t:null}conditionsCheck(e){var t;t=this.computeCapacity();return null==t||e<=t}__incrementReservoir__(e){var t=this;return _asyncToGenerator((function*(){var n;yield t.yieldLoop();n=t.storeOptions.reservoir+=e;t.instance._drainAll(t.computeCapacity());return n}))()}__currentReservoir__(){var e=this;return _asyncToGenerator((function*(){yield e.yieldLoop();return e.storeOptions.reservoir}))()}isBlocked(e){return this._unblockTime>=e}check(e,t){return this.conditionsCheck(e)&&this._nextRequest-t<=0}__check__(e){var t=this;return _asyncToGenerator((function*(){var n;yield t.yieldLoop();n=Date.now();return t.check(e,n)}))()}__register__(e,t,n){var r=this;return _asyncToGenerator((function*(){var e,n;yield r.yieldLoop();e=Date.now();if(r.conditionsCheck(t)){r._running+=t;null!=r.storeOptions.reservoir&&(r.storeOptions.reservoir-=t);n=Math.max(r._nextRequest-e,0);r._nextRequest=e+n+r.storeOptions.minTime;return{success:true,wait:n,reservoir:r.storeOptions.reservoir}}return{success:false}}))()}strategyIsBlock(){return 3===this.storeOptions.strategy}__submit__(t,n){var r=this;return _asyncToGenerator((function*(){var i,s,o;yield r.yieldLoop();if(null!=r.storeOptions.maxConcurrent&&n>r.storeOptions.maxConcurrent)throw new e(`Impossible to add a job having a weight of ${n} to a limiter having a maxConcurrent setting of ${r.storeOptions.maxConcurrent}`);s=Date.now();o=null!=r.storeOptions.highWater&&t===r.storeOptions.highWater&&!r.check(n,s);i=r.strategyIsBlock()&&(o||r.isBlocked(s));if(i){r._unblockTime=s+r.computePenalty();r._nextRequest=r._unblockTime+r.storeOptions.minTime;r.instance._dropAllQueued()}return{reachedHWM:o,blocked:i,strategy:r.storeOptions.strategy}}))()}__free__(e,t){var n=this;return _asyncToGenerator((function*(){yield n.yieldLoop();n._running-=t;n._done+=t;n.instance._drainAll(n.computeCapacity());return{running:n._running}}))()}};exports$6=t;return exports$6}var _lua={"blacklist_client.lua":"local blacklist = ARGV[num_static_argv + 1]\n\nif redis.call('zscore', client_last_seen_key, blacklist) then\n  redis.call('zadd', client_last_seen_key, 0, blacklist)\nend\n\n\nreturn {}\n","check.lua":"local weight = tonumber(ARGV[num_static_argv + 1])\n\nlocal capacity = process_tick(now, false)['capacity']\nlocal nextRequest = tonumber(redis.call('hget', settings_key, 'nextRequest'))\n\nreturn conditions_check(capacity, weight) and nextRequest - now <= 0\n","conditions_check.lua":"local conditions_check = function (capacity, weight)\n  return capacity == nil or weight <= capacity\nend\n","current_reservoir.lua":"return process_tick(now, false)['reservoir']\n","done.lua":"process_tick(now, false)\n\nreturn tonumber(redis.call('hget', settings_key, 'done'))\n","free.lua":"local index = ARGV[num_static_argv + 1]\n\nredis.call('zadd', job_expirations_key, 0, index)\n\nreturn process_tick(now, false)['running']\n","get_time.lua":"redis.replicate_commands()\n\nlocal get_time = function ()\n  local time = redis.call('time')\n\n  return tonumber(time[1]..string.sub(time[2], 1, 3))\nend\n","group_check.lua":"return not (redis.call('exists', settings_key) == 1)\n","heartbeat.lua":"process_tick(now, true)\n","increment_reservoir.lua":"local incr = tonumber(ARGV[num_static_argv + 1])\n\nredis.call('hincrby', settings_key, 'reservoir', incr)\n\nlocal reservoir = process_tick(now, true)['reservoir']\n\nlocal groupTimeout = tonumber(redis.call('hget', settings_key, 'groupTimeout'))\nrefresh_expiration(0, 0, groupTimeout)\n\nreturn reservoir\n","init.lua":"local clear = tonumber(ARGV[num_static_argv + 1])\nlocal limiter_version = ARGV[num_static_argv + 2]\nlocal num_local_argv = num_static_argv + 2\n\nif clear == 1 then\n  redis.call('del', unpack(KEYS))\nend\n\nif redis.call('exists', settings_key) == 0 then\n  -- Create\n  local args = {'hmset', settings_key}\n\n  for i = num_local_argv + 1, #ARGV do\n    table.insert(args, ARGV[i])\n  end\n\n  redis.call(unpack(args))\n  redis.call('hmset', settings_key,\n    'nextRequest', now,\n    'lastReservoirRefresh', now,\n    'lastReservoirIncrease', now,\n    'running', 0,\n    'done', 0,\n    'unblockTime', 0,\n    'capacityPriorityCounter', 0\n  )\n\nelse\n  -- Apply migrations\n  local settings = redis.call('hmget', settings_key,\n    'id',\n    'version'\n  )\n  local id = settings[1]\n  local current_version = settings[2]\n\n  if current_version ~= limiter_version then\n    local version_digits = {}\n    for k, v in string.gmatch(current_version, \"([^.]+)\") do\n      table.insert(version_digits, tonumber(k))\n    end\n\n    -- 2.10.0\n    if version_digits[2] < 10 then\n      redis.call('hsetnx', settings_key, 'reservoirRefreshInterval', '')\n      redis.call('hsetnx', settings_key, 'reservoirRefreshAmount', '')\n      redis.call('hsetnx', settings_key, 'lastReservoirRefresh', '')\n      redis.call('hsetnx', settings_key, 'done', 0)\n      redis.call('hset', settings_key, 'version', '2.10.0')\n    end\n\n    -- 2.11.1\n    if version_digits[2] < 11 or (version_digits[2] == 11 and version_digits[3] < 1) then\n      if redis.call('hstrlen', settings_key, 'lastReservoirRefresh') == 0 then\n        redis.call('hmset', settings_key,\n          'lastReservoirRefresh', now,\n          'version', '2.11.1'\n        )\n      end\n    end\n\n    -- 2.14.0\n    if version_digits[2] < 14 then\n      local old_running_key = 'b_'..id..'_running'\n      local old_executing_key = 'b_'..id..'_executing'\n\n      if redis.call('exists', old_running_key) == 1 then\n        redis.call('rename', old_running_key, job_weights_key)\n      end\n      if redis.call('exists', old_executing_key) == 1 then\n        redis.call('rename', old_executing_key, job_expirations_key)\n      end\n      redis.call('hset', settings_key, 'version', '2.14.0')\n    end\n\n    -- 2.15.2\n    if version_digits[2] < 15 or (version_digits[2] == 15 and version_digits[3] < 2) then\n      redis.call('hsetnx', settings_key, 'capacityPriorityCounter', 0)\n      redis.call('hset', settings_key, 'version', '2.15.2')\n    end\n\n    -- 2.17.0\n    if version_digits[2] < 17 then\n      redis.call('hsetnx', settings_key, 'clientTimeout', 10000)\n      redis.call('hset', settings_key, 'version', '2.17.0')\n    end\n\n    -- 2.18.0\n    if version_digits[2] < 18 then\n      redis.call('hsetnx', settings_key, 'reservoirIncreaseInterval', '')\n      redis.call('hsetnx', settings_key, 'reservoirIncreaseAmount', '')\n      redis.call('hsetnx', settings_key, 'reservoirIncreaseMaximum', '')\n      redis.call('hsetnx', settings_key, 'lastReservoirIncrease', now)\n      redis.call('hset', settings_key, 'version', '2.18.0')\n    end\n\n  end\n\n  process_tick(now, false)\nend\n\nlocal groupTimeout = tonumber(redis.call('hget', settings_key, 'groupTimeout'))\nrefresh_expiration(0, 0, groupTimeout)\n\nreturn {}\n","process_tick.lua":"local process_tick = function (now, always_publish)\n\n  local compute_capacity = function (maxConcurrent, running, reservoir)\n    if maxConcurrent ~= nil and reservoir ~= nil then\n      return math.min((maxConcurrent - running), reservoir)\n    elseif maxConcurrent ~= nil then\n      return maxConcurrent - running\n    elseif reservoir ~= nil then\n      return reservoir\n    else\n      return nil\n    end\n  end\n\n  local settings = redis.call('hmget', settings_key,\n    'id',\n    'maxConcurrent',\n    'running',\n    'reservoir',\n    'reservoirRefreshInterval',\n    'reservoirRefreshAmount',\n    'lastReservoirRefresh',\n    'reservoirIncreaseInterval',\n    'reservoirIncreaseAmount',\n    'reservoirIncreaseMaximum',\n    'lastReservoirIncrease',\n    'capacityPriorityCounter',\n    'clientTimeout'\n  )\n  local id = settings[1]\n  local maxConcurrent = tonumber(settings[2])\n  local running = tonumber(settings[3])\n  local reservoir = tonumber(settings[4])\n  local reservoirRefreshInterval = tonumber(settings[5])\n  local reservoirRefreshAmount = tonumber(settings[6])\n  local lastReservoirRefresh = tonumber(settings[7])\n  local reservoirIncreaseInterval = tonumber(settings[8])\n  local reservoirIncreaseAmount = tonumber(settings[9])\n  local reservoirIncreaseMaximum = tonumber(settings[10])\n  local lastReservoirIncrease = tonumber(settings[11])\n  local capacityPriorityCounter = tonumber(settings[12])\n  local clientTimeout = tonumber(settings[13])\n\n  local initial_capacity = compute_capacity(maxConcurrent, running, reservoir)\n\n  --\n  -- Process 'running' changes\n  --\n  local expired = redis.call('zrangebyscore', job_expirations_key, '-inf', '('..now)\n\n  if #expired > 0 then\n    redis.call('zremrangebyscore', job_expirations_key, '-inf', '('..now)\n\n    local flush_batch = function (batch, acc)\n      local weights = redis.call('hmget', job_weights_key, unpack(batch))\n                      redis.call('hdel',  job_weights_key, unpack(batch))\n      local clients = redis.call('hmget', job_clients_key, unpack(batch))\n                      redis.call('hdel',  job_clients_key, unpack(batch))\n\n      -- Calculate sum of removed weights\n      for i = 1, #weights do\n        acc['total'] = acc['total'] + (tonumber(weights[i]) or 0)\n      end\n\n      -- Calculate sum of removed weights by client\n      local client_weights = {}\n      for i = 1, #clients do\n        local removed = tonumber(weights[i]) or 0\n        if removed > 0 then\n          acc['client_weights'][clients[i]] = (acc['client_weights'][clients[i]] or 0) + removed\n        end\n      end\n    end\n\n    local acc = {\n      ['total'] = 0,\n      ['client_weights'] = {}\n    }\n    local batch_size = 1000\n\n    -- Compute changes to Zsets and apply changes to Hashes\n    for i = 1, #expired, batch_size do\n      local batch = {}\n      for j = i, math.min(i + batch_size - 1, #expired) do\n        table.insert(batch, expired[j])\n      end\n\n      flush_batch(batch, acc)\n    end\n\n    -- Apply changes to Zsets\n    if acc['total'] > 0 then\n      redis.call('hincrby', settings_key, 'done', acc['total'])\n      running = tonumber(redis.call('hincrby', settings_key, 'running', -acc['total']))\n    end\n\n    for client, weight in pairs(acc['client_weights']) do\n      redis.call('zincrby', client_running_key, -weight, client)\n    end\n  end\n\n  --\n  -- Process 'reservoir' changes\n  --\n  local reservoirRefreshActive = reservoirRefreshInterval ~= nil and reservoirRefreshAmount ~= nil\n  if reservoirRefreshActive and now >= lastReservoirRefresh + reservoirRefreshInterval then\n    reservoir = reservoirRefreshAmount\n    redis.call('hmset', settings_key,\n      'reservoir', reservoir,\n      'lastReservoirRefresh', now\n    )\n  end\n\n  local reservoirIncreaseActive = reservoirIncreaseInterval ~= nil and reservoirIncreaseAmount ~= nil\n  if reservoirIncreaseActive and now >= lastReservoirIncrease + reservoirIncreaseInterval then\n    local num_intervals = math.floor((now - lastReservoirIncrease) / reservoirIncreaseInterval)\n    local incr = reservoirIncreaseAmount * num_intervals\n    if reservoirIncreaseMaximum ~= nil then\n      incr = math.min(incr, reservoirIncreaseMaximum - (reservoir or 0))\n    end\n    if incr > 0 then\n      reservoir = (reservoir or 0) + incr\n    end\n    redis.call('hmset', settings_key,\n      'reservoir', reservoir,\n      'lastReservoirIncrease', lastReservoirIncrease + (num_intervals * reservoirIncreaseInterval)\n    )\n  end\n\n  --\n  -- Clear unresponsive clients\n  --\n  local unresponsive = redis.call('zrangebyscore', client_last_seen_key, '-inf', (now - clientTimeout))\n  local unresponsive_lookup = {}\n  local terminated_clients = {}\n  for i = 1, #unresponsive do\n    unresponsive_lookup[unresponsive[i]] = true\n    if tonumber(redis.call('zscore', client_running_key, unresponsive[i])) == 0 then\n      table.insert(terminated_clients, unresponsive[i])\n    end\n  end\n  if #terminated_clients > 0 then\n    redis.call('zrem', client_running_key,         unpack(terminated_clients))\n    redis.call('hdel', client_num_queued_key,      unpack(terminated_clients))\n    redis.call('zrem', client_last_registered_key, unpack(terminated_clients))\n    redis.call('zrem', client_last_seen_key,       unpack(terminated_clients))\n  end\n\n  --\n  -- Broadcast capacity changes\n  --\n  local final_capacity = compute_capacity(maxConcurrent, running, reservoir)\n\n  if always_publish or (initial_capacity ~= nil and final_capacity == nil) then\n    -- always_publish or was not unlimited, now unlimited\n    redis.call('publish', 'b_'..id, 'capacity:'..(final_capacity or ''))\n\n  elseif initial_capacity ~= nil and final_capacity ~= nil and final_capacity > initial_capacity then\n    -- capacity was increased\n    -- send the capacity message to the limiter having the lowest number of running jobs\n    -- the tiebreaker is the limiter having not registered a job in the longest time\n\n    local lowest_concurrency_value = nil\n    local lowest_concurrency_clients = {}\n    local lowest_concurrency_last_registered = {}\n    local client_concurrencies = redis.call('zrange', client_running_key, 0, -1, 'withscores')\n\n    for i = 1, #client_concurrencies, 2 do\n      local client = client_concurrencies[i]\n      local concurrency = tonumber(client_concurrencies[i+1])\n\n      if (\n        lowest_concurrency_value == nil or lowest_concurrency_value == concurrency\n      ) and (\n        not unresponsive_lookup[client]\n      ) and (\n        tonumber(redis.call('hget', client_num_queued_key, client)) > 0\n      ) then\n        lowest_concurrency_value = concurrency\n        table.insert(lowest_concurrency_clients, client)\n        local last_registered = tonumber(redis.call('zscore', client_last_registered_key, client))\n        table.insert(lowest_concurrency_last_registered, last_registered)\n      end\n    end\n\n    if #lowest_concurrency_clients > 0 then\n      local position = 1\n      local earliest = lowest_concurrency_last_registered[1]\n\n      for i,v in ipairs(lowest_concurrency_last_registered) do\n        if v < earliest then\n          position = i\n          earliest = v\n        end\n      end\n\n      local next_client = lowest_concurrency_clients[position]\n      redis.call('publish', 'b_'..id,\n        'capacity-priority:'..(final_capacity or '')..\n        ':'..next_client..\n        ':'..capacityPriorityCounter\n      )\n      redis.call('hincrby', settings_key, 'capacityPriorityCounter', '1')\n    else\n      redis.call('publish', 'b_'..id, 'capacity:'..(final_capacity or ''))\n    end\n  end\n\n  return {\n    ['capacity'] = final_capacity,\n    ['running'] = running,\n    ['reservoir'] = reservoir\n  }\nend\n","queued.lua":"local clientTimeout = tonumber(redis.call('hget', settings_key, 'clientTimeout'))\nlocal valid_clients = redis.call('zrangebyscore', client_last_seen_key, (now - clientTimeout), 'inf')\nlocal client_queued = redis.call('hmget', client_num_queued_key, unpack(valid_clients))\n\nlocal sum = 0\nfor i = 1, #client_queued do\n  sum = sum + tonumber(client_queued[i])\nend\n\nreturn sum\n","refresh_expiration.lua":"local refresh_expiration = function (now, nextRequest, groupTimeout)\n\n  if groupTimeout ~= nil then\n    local ttl = (nextRequest + groupTimeout) - now\n\n    for i = 1, #KEYS do\n      redis.call('pexpire', KEYS[i], ttl)\n    end\n  end\n\nend\n","refs.lua":"local settings_key = KEYS[1]\nlocal job_weights_key = KEYS[2]\nlocal job_expirations_key = KEYS[3]\nlocal job_clients_key = KEYS[4]\nlocal client_running_key = KEYS[5]\nlocal client_num_queued_key = KEYS[6]\nlocal client_last_registered_key = KEYS[7]\nlocal client_last_seen_key = KEYS[8]\n\nlocal now = tonumber(ARGV[1])\nlocal client = ARGV[2]\n\nlocal num_static_argv = 2\n","register.lua":"local index = ARGV[num_static_argv + 1]\nlocal weight = tonumber(ARGV[num_static_argv + 2])\nlocal expiration = tonumber(ARGV[num_static_argv + 3])\n\nlocal state = process_tick(now, false)\nlocal capacity = state['capacity']\nlocal reservoir = state['reservoir']\n\nlocal settings = redis.call('hmget', settings_key,\n  'nextRequest',\n  'minTime',\n  'groupTimeout'\n)\nlocal nextRequest = tonumber(settings[1])\nlocal minTime = tonumber(settings[2])\nlocal groupTimeout = tonumber(settings[3])\n\nif conditions_check(capacity, weight) then\n\n  redis.call('hincrby', settings_key, 'running', weight)\n  redis.call('hset', job_weights_key, index, weight)\n  if expiration ~= nil then\n    redis.call('zadd', job_expirations_key, now + expiration, index)\n  end\n  redis.call('hset', job_clients_key, index, client)\n  redis.call('zincrby', client_running_key, weight, client)\n  redis.call('hincrby', client_num_queued_key, client, -1)\n  redis.call('zadd', client_last_registered_key, now, client)\n\n  local wait = math.max(nextRequest - now, 0)\n  local newNextRequest = now + wait + minTime\n\n  if reservoir == nil then\n    redis.call('hset', settings_key,\n      'nextRequest', newNextRequest\n    )\n  else\n    reservoir = reservoir - weight\n    redis.call('hmset', settings_key,\n      'reservoir', reservoir,\n      'nextRequest', newNextRequest\n    )\n  end\n\n  refresh_expiration(now, newNextRequest, groupTimeout)\n\n  return {true, wait, reservoir}\n\nelse\n  return {false}\nend\n","register_client.lua":"local queued = tonumber(ARGV[num_static_argv + 1])\n\n-- Could have been re-registered concurrently\nif not redis.call('zscore', client_last_seen_key, client) then\n  redis.call('zadd', client_running_key, 0, client)\n  redis.call('hset', client_num_queued_key, client, queued)\n  redis.call('zadd', client_last_registered_key, 0, client)\nend\n\nredis.call('zadd', client_last_seen_key, now, client)\n\nreturn {}\n","running.lua":"return process_tick(now, false)['running']\n","submit.lua":"local queueLength = tonumber(ARGV[num_static_argv + 1])\nlocal weight = tonumber(ARGV[num_static_argv + 2])\n\nlocal capacity = process_tick(now, false)['capacity']\n\nlocal settings = redis.call('hmget', settings_key,\n  'id',\n  'maxConcurrent',\n  'highWater',\n  'nextRequest',\n  'strategy',\n  'unblockTime',\n  'penalty',\n  'minTime',\n  'groupTimeout'\n)\nlocal id = settings[1]\nlocal maxConcurrent = tonumber(settings[2])\nlocal highWater = tonumber(settings[3])\nlocal nextRequest = tonumber(settings[4])\nlocal strategy = tonumber(settings[5])\nlocal unblockTime = tonumber(settings[6])\nlocal penalty = tonumber(settings[7])\nlocal minTime = tonumber(settings[8])\nlocal groupTimeout = tonumber(settings[9])\n\nif maxConcurrent ~= nil and weight > maxConcurrent then\n  return redis.error_reply('OVERWEIGHT:'..weight..':'..maxConcurrent)\nend\n\nlocal reachedHWM = (highWater ~= nil and queueLength == highWater\n  and not (\n    conditions_check(capacity, weight)\n    and nextRequest - now <= 0\n  )\n)\n\nlocal blocked = strategy == 3 and (reachedHWM or unblockTime >= now)\n\nif blocked then\n  local computedPenalty = penalty\n  if computedPenalty == nil then\n    if minTime == 0 then\n      computedPenalty = 5000\n    else\n      computedPenalty = 15 * minTime\n    end\n  end\n\n  local newNextRequest = now + computedPenalty + minTime\n\n  redis.call('hmset', settings_key,\n    'unblockTime', now + computedPenalty,\n    'nextRequest', newNextRequest\n  )\n\n  local clients_queued_reset = redis.call('hkeys', client_num_queued_key)\n  local queued_reset = {}\n  for i = 1, #clients_queued_reset do\n    table.insert(queued_reset, clients_queued_reset[i])\n    table.insert(queued_reset, 0)\n  end\n  redis.call('hmset', client_num_queued_key, unpack(queued_reset))\n\n  redis.call('publish', 'b_'..id, 'blocked:')\n\n  refresh_expiration(now, newNextRequest, groupTimeout)\nend\n\nif not blocked and not reachedHWM then\n  redis.call('hincrby', client_num_queued_key, client, 1)\nend\n\nreturn {reachedHWM, blocked, strategy}\n","update_settings.lua":"local args = {'hmset', settings_key}\n\nfor i = num_static_argv + 1, #ARGV do\n  table.insert(args, ARGV[i])\nend\n\nredis.call(unpack(args))\n\nprocess_tick(now, true)\n\nlocal groupTimeout = tonumber(redis.call('hget', settings_key, 'groupTimeout'))\nrefresh_expiration(0, 0, groupTimeout)\n\nreturn {}\n","validate_client.lua":"if not redis.call('zscore', client_last_seen_key, client) then\n  return redis.error_reply('UNKNOWN_CLIENT')\nend\n\nredis.call('zadd', client_last_seen_key, now, client)\n","validate_keys.lua":"if not (redis.call('exists', settings_key) == 1) then\n  return redis.error_reply('SETTINGS_KEY_NOT_FOUND')\nend\n"};var exports$7={},_dewExec$7=false;function dew$7(){if(_dewExec$7)return exports$7;_dewExec$7=true;var e,t,n;t=_lua;e={refs:t["refs.lua"],validate_keys:t["validate_keys.lua"],validate_client:t["validate_client.lua"],refresh_expiration:t["refresh_expiration.lua"],process_tick:t["process_tick.lua"],conditions_check:t["conditions_check.lua"],get_time:t["get_time.lua"]};exports$7.allKeys=function(e){return[`b_${e}_settings`,`b_${e}_job_weights`,`b_${e}_job_expirations`,`b_${e}_job_clients`,`b_${e}_client_running`,`b_${e}_client_num_queued`,`b_${e}_client_last_registered`,`b_${e}_client_last_seen`]};n={init:{keys:exports$7.allKeys,headers:["process_tick"],refresh_expiration:true,code:t["init.lua"]},group_check:{keys:exports$7.allKeys,headers:[],refresh_expiration:false,code:t["group_check.lua"]},register_client:{keys:exports$7.allKeys,headers:["validate_keys"],refresh_expiration:false,code:t["register_client.lua"]},blacklist_client:{keys:exports$7.allKeys,headers:["validate_keys","validate_client"],refresh_expiration:false,code:t["blacklist_client.lua"]},heartbeat:{keys:exports$7.allKeys,headers:["validate_keys","validate_client","process_tick"],refresh_expiration:false,code:t["heartbeat.lua"]},update_settings:{keys:exports$7.allKeys,headers:["validate_keys","validate_client","process_tick"],refresh_expiration:true,code:t["update_settings.lua"]},running:{keys:exports$7.allKeys,headers:["validate_keys","validate_client","process_tick"],refresh_expiration:false,code:t["running.lua"]},queued:{keys:exports$7.allKeys,headers:["validate_keys","validate_client"],refresh_expiration:false,code:t["queued.lua"]},done:{keys:exports$7.allKeys,headers:["validate_keys","validate_client","process_tick"],refresh_expiration:false,code:t["done.lua"]},check:{keys:exports$7.allKeys,headers:["validate_keys","validate_client","process_tick","conditions_check"],refresh_expiration:false,code:t["check.lua"]},submit:{keys:exports$7.allKeys,headers:["validate_keys","validate_client","process_tick","conditions_check"],refresh_expiration:true,code:t["submit.lua"]},register:{keys:exports$7.allKeys,headers:["validate_keys","validate_client","process_tick","conditions_check"],refresh_expiration:true,code:t["register.lua"]},free:{keys:exports$7.allKeys,headers:["validate_keys","validate_client","process_tick"],refresh_expiration:true,code:t["free.lua"]},current_reservoir:{keys:exports$7.allKeys,headers:["validate_keys","validate_client","process_tick"],refresh_expiration:false,code:t["current_reservoir.lua"]},increment_reservoir:{keys:exports$7.allKeys,headers:["validate_keys","validate_client","process_tick"],refresh_expiration:true,code:t["increment_reservoir.lua"]}};exports$7.names=Object.keys(n);exports$7.keys=function(e,t){return n[e].keys(t)};exports$7.payload=function(t){var r;r=n[t];return Array.prototype.concat(e.refs,r.headers.map((function(t){return e[t]})),r.refresh_expiration?e.refresh_expiration:"",r.code).join("\n")};return exports$7}var exports$8={},_dewExec$8=false;function dew$8(){if(_dewExec$8)return exports$8;_dewExec$8=true;function asyncGeneratorStep(e,t,n,r,i,s,o){try{var a=e[s](o);var l=a.value}catch(e){n(e);return}a.done?t(l):Promise.resolve(l).then(r,i)}function _asyncToGenerator(e){return function(){var t=this,n=arguments;return new Promise((function(r,i){var s=e.apply(t,n);function _next(e){asyncGeneratorStep(s,r,i,_next,_throw,"next",e)}function _throw(e){asyncGeneratorStep(s,r,i,_next,_throw,"throw",e)}_next(void 0)}))}}var Events,RedisConnection,Scripts,parser;parser=dew();Events=dew$2();Scripts=dew$7();RedisConnection=function(){class RedisConnection{constructor(options={}){parser.load(options,this.defaults,this);null==this.Redis&&(this.Redis=eval("require")("redis"));null==this.Events&&(this.Events=new Events(this));this.terminated=false;null==this.client&&(this.client=this.Redis.createClient(this.clientOptions));this.subscriber=this.client.duplicate();this.limiters={};this.shas={};this.ready=this.Promise.all([this._setup(this.client,false),this._setup(this.subscriber,true)]).then(()=>this._loadScripts()).then(()=>({client:this.client,subscriber:this.subscriber}))}_setup(e,t){e.setMaxListeners(0);return new this.Promise((n,r)=>{e.on("error",e=>this.Events.trigger("error",e));t&&e.on("message",(e,t)=>{var n;return null!=(n=this.limiters[e])?n._store.onMessage(e,t):void 0});return e.ready?n():e.once("ready",n)})}_loadScript(e){return new this.Promise((t,n)=>{var r;r=Scripts.payload(e);return this.client.multi([["script","load",r]]).exec((r,i)=>{if(null!=r)return n(r);this.shas[e]=i[0];return t(i[0])})})}_loadScripts(){return this.Promise.all(Scripts.names.map(e=>this._loadScript(e)))}__runCommand__(e){var t=this;return _asyncToGenerator((function*(){yield t.ready;return new t.Promise((n,r)=>t.client.multi([e]).exec_atomic((function(e,t){return null!=e?r(e):n(t[0])})))}))()}__addLimiter__(e){return this.Promise.all([e.channel(),e.channel_client()].map(t=>new this.Promise((n,r)=>{var i;i=r=>{if(r===t){this.subscriber.removeListener("subscribe",i);this.limiters[t]=e;return n()}};this.subscriber.on("subscribe",i);return this.subscriber.subscribe(t)})))}__removeLimiter__(e){var t=this;return this.Promise.all([e.channel(),e.channel_client()].map(function(){var e=_asyncToGenerator((function*(e){t.terminated||(yield new t.Promise((n,r)=>t.subscriber.unsubscribe(e,(function(t,i){return null!=t?r(t):i===e?n():void 0}))));return delete t.limiters[e]}));return function(t){return e.apply(this,arguments)}}()))}__scriptArgs__(e,t,n,r){var i;i=Scripts.keys(e,t);return[this.shas[e],i.length].concat(i,n,r)}__scriptFn__(e){return this.client.evalsha.bind(this.client)}disconnect(e=true){var t,n,r,i;i=Object.keys(this.limiters);for(t=0,r=i.length;t<r;t++){n=i[t];clearInterval(this.limiters[n]._store.heartbeat)}this.limiters={};this.terminated=true;this.client.end(e);this.subscriber.end(e);return this.Promise.resolve()}}RedisConnection.prototype.datastore="redis";RedisConnection.prototype.defaults={Redis:null,clientOptions:{},client:null,Promise:Promise,Events:null};return RedisConnection}.call(void 0);exports$8=RedisConnection;return exports$8}var exports$9={},_dewExec$9=false;function dew$9(){if(_dewExec$9)return exports$9;_dewExec$9=true;function _slicedToArray(e,t){return _arrayWithHoles(e)||_iterableToArrayLimit(e,t)||_nonIterableRest()}function _nonIterableRest(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}function _iterableToArrayLimit(e,t){var n=[];var r=true;var i=false;var s=void 0;try{for(var o=e[Symbol.iterator](),a;!(r=(a=o.next()).done);r=true){n.push(a.value);if(t&&n.length===t)break}}catch(e){i=true;s=e}finally{try{r||null==o["return"]||o["return"]()}finally{if(i)throw s}}return n}function _arrayWithHoles(e){if(Array.isArray(e))return e}function asyncGeneratorStep(e,t,n,r,i,s,o){try{var a=e[s](o);var l=a.value}catch(e){n(e);return}a.done?t(l):Promise.resolve(l).then(r,i)}function _asyncToGenerator(e){return function(){var t=this,n=arguments;return new Promise((function(r,i){var s=e.apply(t,n);function _next(e){asyncGeneratorStep(s,r,i,_next,_throw,"next",e)}function _throw(e){asyncGeneratorStep(s,r,i,_next,_throw,"throw",e)}_next(void 0)}))}}var Events,IORedisConnection,Scripts,parser;parser=dew();Events=dew$2();Scripts=dew$7();IORedisConnection=function(){class IORedisConnection{constructor(options={}){parser.load(options,this.defaults,this);null==this.Redis&&(this.Redis=eval("require")("ioredis"));null==this.Events&&(this.Events=new Events(this));this.terminated=false;if(null!=this.clusterNodes){this.client=new this.Redis.Cluster(this.clusterNodes,this.clientOptions);this.subscriber=new this.Redis.Cluster(this.clusterNodes,this.clientOptions)}else if(null!=this.client&&null==this.client.duplicate)this.subscriber=new this.Redis.Cluster(this.client.startupNodes,this.client.options);else{null==this.client&&(this.client=new this.Redis(this.clientOptions));this.subscriber=this.client.duplicate()}this.limiters={};this.ready=this.Promise.all([this._setup(this.client,false),this._setup(this.subscriber,true)]).then(()=>{this._loadScripts();return{client:this.client,subscriber:this.subscriber}})}_setup(e,t){e.setMaxListeners(0);return new this.Promise((n,r)=>{e.on("error",e=>this.Events.trigger("error",e));t&&e.on("message",(e,t)=>{var n;return null!=(n=this.limiters[e])?n._store.onMessage(e,t):void 0});return"ready"===e.status?n():e.once("ready",n)})}_loadScripts(){return Scripts.names.forEach(e=>this.client.defineCommand(e,{lua:Scripts.payload(e)}))}__runCommand__(e){var t=this;return _asyncToGenerator((function*(){var n,r;yield t.ready;var i=yield t.client.pipeline([e]).exec();var s=_slicedToArray(i,1);var o=_slicedToArray(s[0],2);n=o[0];r=o[1];return r}))()}__addLimiter__(e){return this.Promise.all([e.channel(),e.channel_client()].map(t=>new this.Promise((n,r)=>this.subscriber.subscribe(t,()=>{this.limiters[t]=e;return n()}))))}__removeLimiter__(e){var t=this;return[e.channel(),e.channel_client()].forEach(function(){var e=_asyncToGenerator((function*(e){t.terminated||(yield t.subscriber.unsubscribe(e));return delete t.limiters[e]}));return function(t){return e.apply(this,arguments)}}())}__scriptArgs__(e,t,n,r){var i;i=Scripts.keys(e,t);return[i.length].concat(i,n,r)}__scriptFn__(e){return this.client[e].bind(this.client)}disconnect(e=true){var t,n,r,i;i=Object.keys(this.limiters);for(t=0,r=i.length;t<r;t++){n=i[t];clearInterval(this.limiters[n]._store.heartbeat)}this.limiters={};this.terminated=true;if(e)return this.Promise.all([this.client.quit(),this.subscriber.quit()]);this.client.disconnect();this.subscriber.disconnect();return this.Promise.resolve()}}IORedisConnection.prototype.datastore="ioredis";IORedisConnection.prototype.defaults={Redis:null,clientOptions:{},clusterNodes:null,client:null,Promise:Promise,Events:null};return IORedisConnection}.call(void 0);exports$9=IORedisConnection;return exports$9}var exports$a={},_dewExec$a=false;function dew$a(){if(_dewExec$a)return exports$a;_dewExec$a=true;function _slicedToArray(e,t){return _arrayWithHoles(e)||_iterableToArrayLimit(e,t)||_nonIterableRest()}function _nonIterableRest(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}function _iterableToArrayLimit(e,t){var n=[];var r=true;var i=false;var s=void 0;try{for(var o=e[Symbol.iterator](),a;!(r=(a=o.next()).done);r=true){n.push(a.value);if(t&&n.length===t)break}}catch(e){i=true;s=e}finally{try{r||null==o["return"]||o["return"]()}finally{if(i)throw s}}return n}function _arrayWithHoles(e){if(Array.isArray(e))return e}function asyncGeneratorStep(e,t,n,r,i,s,o){try{var a=e[s](o);var l=a.value}catch(e){n(e);return}a.done?t(l):Promise.resolve(l).then(r,i)}function _asyncToGenerator(e){return function(){var t=this,n=arguments;return new Promise((function(r,i){var s=e.apply(t,n);function _next(e){asyncGeneratorStep(s,r,i,_next,_throw,"next",e)}function _throw(e){asyncGeneratorStep(s,r,i,_next,_throw,"throw",e)}_next(void 0)}))}}var e,t,n,r,i;i=dew();e=dew$4();n=dew$8();t=dew$9();r=class RedisDatastore{constructor(e,r,s){this.instance=e;this.storeOptions=r;this.originalId=this.instance.id;this.clientId=this.instance._randomIndex();i.load(s,s,this);this.clients={};this.capacityPriorityCounters={};this.sharedConnection=null!=this.connection;null==this.connection&&(this.connection="redis"===this.instance.datastore?new n({Redis:this.Redis,clientOptions:this.clientOptions,Promise:this.Promise,Events:this.instance.Events}):"ioredis"===this.instance.datastore?new t({Redis:this.Redis,clientOptions:this.clientOptions,clusterNodes:this.clusterNodes,Promise:this.Promise,Events:this.instance.Events}):void 0);this.instance.connection=this.connection;this.instance.datastore=this.connection.datastore;this.ready=this.connection.ready.then(e=>{this.clients=e;return this.runScript("init",this.prepareInitSettings(this.clearDatastore))}).then(()=>this.connection.__addLimiter__(this.instance)).then(()=>this.runScript("register_client",[this.instance.queued()])).then(()=>{var e;"function"===typeof(e=this.heartbeat=setInterval(()=>this.runScript("heartbeat",[]).catch(e=>this.instance.Events.trigger("error",e)),this.heartbeatInterval)).unref&&e.unref();return this.clients})}__publish__(e){var t=this;return _asyncToGenerator((function*(){var n;var r=yield t.ready;n=r.client;return n.publish(t.instance.channel(),`message:${e.toString()}`)}))()}onMessage(e,t){var n=this;return _asyncToGenerator((function*(){var e,r,i,s,o,a,l,c,u,h;try{l=t.indexOf(":");var _=[t.slice(0,l),t.slice(l+1)];h=_[0];i=_[1];if("capacity"===h)return yield n.instance._drainAll(i.length>0?~~i:void 0);if("capacity-priority"===h){var d=i.split(":");var p=_slicedToArray(d,3);u=p[0];c=p[1];r=p[2];e=u.length>0?~~u:void 0;if(c===n.clientId){s=yield n.instance._drainAll(e);a=null!=e?e-(s||0):"";return yield n.clients.client.publish(n.instance.channel(),`capacity-priority:${a}::${r}`)}if(""===c){clearTimeout(n.capacityPriorityCounters[r]);delete n.capacityPriorityCounters[r];return n.instance._drainAll(e)}return n.capacityPriorityCounters[r]=setTimeout(_asyncToGenerator((function*(){var t;try{delete n.capacityPriorityCounters[r];yield n.runScript("blacklist_client",[c]);return yield n.instance._drainAll(e)}catch(e){t=e;return n.instance.Events.trigger("error",t)}})),1e3)}if("message"===h)return n.instance.Events.trigger("message",i);if("blocked"===h)return yield n.instance._dropAllQueued()}catch(e){o=e;return n.instance.Events.trigger("error",o)}}))()}__disconnect__(e){clearInterval(this.heartbeat);return this.sharedConnection?this.connection.__removeLimiter__(this.instance):this.connection.disconnect(e)}runScript(e,t){var n=this;return _asyncToGenerator((function*(){"init"===e||"register_client"===e||(yield n.ready);return new n.Promise((r,i)=>{var s,o;s=[Date.now(),n.clientId].concat(t);n.instance.Events.trigger("debug",`Calling Redis script: ${e}.lua`,s);o=n.connection.__scriptArgs__(e,n.originalId,s,(function(e,t){return null!=e?i(e):r(t)}));return n.connection.__scriptFn__(e)(...o)}).catch(r=>"SETTINGS_KEY_NOT_FOUND"===r.message?"heartbeat"===e?n.Promise.resolve():n.runScript("init",n.prepareInitSettings(false)).then(()=>n.runScript(e,t)):"UNKNOWN_CLIENT"===r.message?n.runScript("register_client",[n.instance.queued()]).then(()=>n.runScript(e,t)):n.Promise.reject(r))}))()}prepareArray(e){var t,n,r,i;r=[];for(t=0,n=e.length;t<n;t++){i=e[t];r.push(null!=i?i.toString():"")}return r}prepareObject(e){var t,n,r;t=[];for(n in e){r=e[n];t.push(n,null!=r?r.toString():"")}return t}prepareInitSettings(e){var t;t=this.prepareObject(Object.assign({},this.storeOptions,{id:this.originalId,version:this.instance.version,groupTimeout:this.timeout,clientTimeout:this.clientTimeout}));t.unshift(e?1:0,this.instance.version);return t}convertBool(e){return!!e}__updateSettings__(e){var t=this;return _asyncToGenerator((function*(){yield t.runScript("update_settings",t.prepareObject(e));return i.overwrite(e,e,t.storeOptions)}))()}__running__(){return this.runScript("running",[])}__queued__(){return this.runScript("queued",[])}__done__(){return this.runScript("done",[])}__groupCheck__(){var e=this;return _asyncToGenerator((function*(){return e.convertBool(yield e.runScript("group_check",[]))}))()}__incrementReservoir__(e){return this.runScript("increment_reservoir",[e])}__currentReservoir__(){return this.runScript("current_reservoir",[])}__check__(e){var t=this;return _asyncToGenerator((function*(){return t.convertBool(yield t.runScript("check",t.prepareArray([e])))}))()}__register__(e,t,n){var r=this;return _asyncToGenerator((function*(){var i,s,o;var a=yield r.runScript("register",r.prepareArray([e,t,n]));var l=_slicedToArray(a,3);s=l[0];o=l[1];i=l[2];return{success:r.convertBool(s),wait:o,reservoir:i}}))()}__submit__(t,n){var r=this;return _asyncToGenerator((function*(){var i,s,o,a,l,c;try{var u=yield r.runScript("submit",r.prepareArray([t,n]));var h=_slicedToArray(u,3);l=h[0];i=h[1];c=h[2];return{reachedHWM:r.convertBool(l),blocked:r.convertBool(i),strategy:c}}catch(t){s=t;if(0===s.message.indexOf("OVERWEIGHT")){var _=s.message.split(":");var d=_slicedToArray(_,3);a=d[0];n=d[1];o=d[2];throw new e(`Impossible to add a job having a weight of ${n} to a limiter having a maxConcurrent setting of ${o}`)}throw s}}))()}__free__(e,t){var n=this;return _asyncToGenerator((function*(){var t;t=yield n.runScript("free",n.prepareArray([e]));return{running:t}}))()}};exports$a=r;return exports$a}var exports$b={},_dewExec$b=false;function dew$b(){if(_dewExec$b)return exports$b;_dewExec$b=true;var e,t;e=dew$4();t=class States{constructor(e){this.status=e;this._jobs={};this.counts=this.status.map((function(){return 0}))}next(e){var t,n;t=this._jobs[e];n=t+1;if(null!=t&&n<this.status.length){this.counts[t]--;this.counts[n]++;return this._jobs[e]++}if(null!=t){this.counts[t]--;return delete this._jobs[e]}}start(e){var t;t=0;this._jobs[e]=t;return this.counts[t]++}remove(e){var t;t=this._jobs[e];if(null!=t){this.counts[t]--;delete this._jobs[e]}return null!=t}jobStatus(e){var t;return null!=(t=this.status[this._jobs[e]])?t:null}statusJobs(t){var n,r,i,s,o;if(null!=t){r=this.status.indexOf(t);if(r<0)throw new e(`status must be one of ${this.status.join(", ")}`);i=this._jobs;s=[];for(n in i){o=i[n];o===r&&s.push(n)}return s}return Object.keys(this._jobs)}statusCounts(){return this.counts.reduce((e,t,n)=>{e[this.status[n]]=t;return e},{})}};exports$b=t;return exports$b}var exports$c={},_dewExec$c=false;function dew$c(){if(_dewExec$c)return exports$c;_dewExec$c=true;function asyncGeneratorStep(e,t,n,r,i,s,o){try{var a=e[s](o);var l=a.value}catch(e){n(e);return}a.done?t(l):Promise.resolve(l).then(r,i)}function _asyncToGenerator(e){return function(){var t=this,n=arguments;return new Promise((function(r,i){var s=e.apply(t,n);function _next(e){asyncGeneratorStep(s,r,i,_next,_throw,"next",e)}function _throw(e){asyncGeneratorStep(s,r,i,_next,_throw,"throw",e)}_next(void 0)}))}}var e,t;e=dew$1();t=class Sync{constructor(t,n){this.schedule=this.schedule.bind(this);this.name=t;this.Promise=n;this._running=0;this._queue=new e}isEmpty(){return 0===this._queue.length}_tryToRun(){var e=this;return _asyncToGenerator((function*(){var t,n,r,i,s,o,a;if(e._running<1&&e._queue.length>0){e._running++;var l=e._queue.shift();a=l.task;t=l.args;s=l.resolve;i=l.reject;n=yield _asyncToGenerator((function*(){try{o=yield a(...t);return function(){return s(o)}}catch(e){r=e;return function(){return i(r)}}}))();e._running--;e._tryToRun();return n()}}))()}schedule(e,...t){var n,r,i;i=r=null;n=new this.Promise((function(e,t){i=e;return r=t}));this._queue.push({task:e,args:t,resolve:i,reject:r});this._tryToRun();return n}};exports$c=t;return exports$c}var _version={version:"2.19.5"};var exports$d={},_dewExec$d=false;function dew$d(){if(_dewExec$d)return exports$d;_dewExec$d=true;function _slicedToArray(e,t){return _arrayWithHoles(e)||_iterableToArrayLimit(e,t)||_nonIterableRest()}function _nonIterableRest(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}function _iterableToArrayLimit(e,t){var n=[];var r=true;var i=false;var s=void 0;try{for(var o=e[Symbol.iterator](),a;!(r=(a=o.next()).done);r=true){n.push(a.value);if(t&&n.length===t)break}}catch(e){i=true;s=e}finally{try{r||null==o["return"]||o["return"]()}finally{if(i)throw s}}return n}function _arrayWithHoles(e){if(Array.isArray(e))return e}function asyncGeneratorStep(e,t,n,r,i,s,o){try{var a=e[s](o);var l=a.value}catch(e){n(e);return}a.done?t(l):Promise.resolve(l).then(r,i)}function _asyncToGenerator(e){return function(){var t=this,n=arguments;return new Promise((function(r,i){var s=e.apply(t,n);function _next(e){asyncGeneratorStep(s,r,i,_next,_throw,"next",e)}function _throw(e){asyncGeneratorStep(s,r,i,_next,_throw,"throw",e)}_next(void 0)}))}}var e,t,n,r,i,s;s=dew();e=dew$2();r=dew$8();n=dew$9();i=dew$7();t=function(){class Group{constructor(t={}){this.deleteKey=this.deleteKey.bind(this);this.limiterOptions=t;s.load(this.limiterOptions,this.defaults,this);this.Events=new e(this);this.instances={};this.Bottleneck=dew$f();this._startAutoCleanup();this.sharedConnection=null!=this.connection;null==this.connection&&("redis"===this.limiterOptions.datastore?this.connection=new r(Object.assign({},this.limiterOptions,{Events:this.Events})):"ioredis"===this.limiterOptions.datastore&&(this.connection=new n(Object.assign({},this.limiterOptions,{Events:this.Events}))))}key(e=""){var t;return null!=(t=this.instances[e])?t:(()=>{var t;t=this.instances[e]=new this.Bottleneck(Object.assign(this.limiterOptions,{id:`${this.id}-${e}`,timeout:this.timeout,connection:this.connection}));this.Events.trigger("created",t,e);return t})()}deleteKey(e=""){var t=this;return _asyncToGenerator((function*(){var n,r;r=t.instances[e];t.connection&&(n=yield t.connection.__runCommand__(["del",...i.allKeys(`${t.id}-${e}`)]));if(null!=r){delete t.instances[e];yield r.disconnect()}return null!=r||n>0}))()}limiters(){var e,t,n,r;t=this.instances;n=[];for(e in t){r=t[e];n.push({key:e,limiter:r})}return n}keys(){return Object.keys(this.instances)}clusterKeys(){var e=this;return _asyncToGenerator((function*(){var t,n,r,i,s,o,a,l,c;if(null==e.connection)return e.Promise.resolve(e.keys());o=[];t=null;c=`b_${e.id}-`.length;n="_settings".length;while(0!==t){var u=yield e.connection.__runCommand__(["scan",null!=t?t:0,"match",`b_${e.id}-*_settings`,"count",1e4]);var h=_slicedToArray(u,2);l=h[0];r=h[1];t=~~l;for(i=0,a=r.length;i<a;i++){s=r[i];o.push(s.slice(c,-n))}}return o}))()}_startAutoCleanup(){var e=this;var t;clearInterval(this.interval);return"function"===typeof(t=this.interval=setInterval(_asyncToGenerator((function*(){var t,n,r,i,s,o;s=Date.now();r=e.instances;i=[];for(n in r){o=r[n];try{(yield o._store.__groupCheck__(s))?i.push(e.deleteKey(n)):i.push(void 0)}catch(e){t=e;i.push(o.Events.trigger("error",t))}}return i})),this.timeout/2)).unref?t.unref():void 0}updateSettings(e={}){s.overwrite(e,this.defaults,this);s.overwrite(e,e,this.limiterOptions);if(null!=e.timeout)return this._startAutoCleanup()}disconnect(e=true){var t;if(!this.sharedConnection)return null!=(t=this.connection)?t.disconnect(e):void 0}}Group.prototype.defaults={timeout:1e3*60*5,connection:null,Promise:Promise,id:"group-key"};return Group}.call(void 0);exports$d=t;return exports$d}var exports$e={},_dewExec$e=false;function dew$e(){if(_dewExec$e)return exports$e;_dewExec$e=true;var e,t,n;n=dew();t=dew$2();e=function(){class Batcher{constructor(e={}){this.options=e;n.load(this.options,this.defaults,this);this.Events=new t(this);this._arr=[];this._resetPromise();this._lastFlush=Date.now()}_resetPromise(){return this._promise=new this.Promise((e,t)=>this._resolve=e)}_flush(){clearTimeout(this._timeout);this._lastFlush=Date.now();this._resolve();this.Events.trigger("batch",this._arr);this._arr=[];return this._resetPromise()}add(e){var t;this._arr.push(e);t=this._promise;this._arr.length===this.maxSize?this._flush():null!=this.maxTime&&1===this._arr.length&&(this._timeout=setTimeout(()=>this._flush(),this.maxTime));return t}}Batcher.prototype.defaults={maxTime:null,maxSize:null,Promise:Promise};return Batcher}.call(void 0);exports$e=e;return exports$e}var exports$f={},_dewExec$f=false;function dew$f(){if(_dewExec$f)return exports$f;_dewExec$f=true;function _slicedToArray(e,t){return _arrayWithHoles(e)||_iterableToArrayLimit(e,t)||_nonIterableRest()}function _iterableToArrayLimit(e,t){var n=[];var r=true;var i=false;var s=void 0;try{for(var o=e[Symbol.iterator](),a;!(r=(a=o.next()).done);r=true){n.push(a.value);if(t&&n.length===t)break}}catch(e){i=true;s=e}finally{try{r||null==o["return"]||o["return"]()}finally{if(i)throw s}}return n}function _toArray(e){return _arrayWithHoles(e)||_iterableToArray(e)||_nonIterableRest()}function _nonIterableRest(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}function _iterableToArray(e){if(Symbol.iterator in Object(e)||"[object Arguments]"===Object.prototype.toString.call(e))return Array.from(e)}function _arrayWithHoles(e){if(Array.isArray(e))return e}function asyncGeneratorStep(e,t,n,r,i,s,o){try{var a=e[s](o);var l=a.value}catch(e){n(e);return}a.done?t(l):Promise.resolve(l).then(r,i)}function _asyncToGenerator(e){return function(){var t=this,n=arguments;return new Promise((function(r,i){var s=e.apply(t,n);function _next(e){asyncGeneratorStep(s,r,i,_next,_throw,"next",e)}function _throw(e){asyncGeneratorStep(s,r,i,_next,_throw,"throw",e)}_next(void 0)}))}}var e,t,n,r,i,s,o,a,l,c,u,h=[].splice;s=10;t=5;u=dew();o=dew$3();r=dew$5();i=dew$6();a=dew$a();n=dew$2();l=dew$b();c=dew$c();e=function(){class Bottleneck{constructor(e={},...t){var r,h;this._addToQueue=this._addToQueue.bind(this);this._validateOptions(e,t);u.load(e,this.instanceDefaults,this);this._queues=new o(s);this._scheduled={};this._states=new l(["RECEIVED","QUEUED","RUNNING","EXECUTING"].concat(this.trackDoneStatus?["DONE"]:[]));this._limiter=null;this.Events=new n(this);this._submitLock=new c("submit",this.Promise);this._registerLock=new c("register",this.Promise);h=u.load(e,this.storeDefaults,{});this._store=function(){if("redis"===this.datastore||"ioredis"===this.datastore||null!=this.connection){r=u.load(e,this.redisStoreDefaults,{});return new a(this,h,r)}if("local"===this.datastore){r=u.load(e,this.localStoreDefaults,{});return new i(this,h,r)}throw new Bottleneck.prototype.BottleneckError(`Invalid datastore type: ${this.datastore}`)}.call(this);this._queues.on("leftzero",()=>{var e;return null!=(e=this._store.heartbeat)&&"function"===typeof e.ref?e.ref():void 0});this._queues.on("zero",()=>{var e;return null!=(e=this._store.heartbeat)&&"function"===typeof e.unref?e.unref():void 0})}_validateOptions(e,t){if(!(null!=e&&"object"===typeof e&&0===t.length))throw new Bottleneck.prototype.BottleneckError("Bottleneck v2 takes a single object argument. Refer to https://github.com/SGrondin/bottleneck#upgrading-to-v2 if you're upgrading from Bottleneck v1.")}ready(){return this._store.ready}clients(){return this._store.clients}channel(){return`b_${this.id}`}channel_client(){return`b_${this.id}_${this._store.clientId}`}publish(e){return this._store.__publish__(e)}disconnect(e=true){return this._store.__disconnect__(e)}chain(e){this._limiter=e;return this}queued(e){return this._queues.queued(e)}clusterQueued(){return this._store.__queued__()}empty(){return 0===this.queued()&&this._submitLock.isEmpty()}running(){return this._store.__running__()}done(){return this._store.__done__()}jobStatus(e){return this._states.jobStatus(e)}jobs(e){return this._states.statusJobs(e)}counts(){return this._states.statusCounts()}_randomIndex(){return Math.random().toString(36).slice(2)}check(e=1){return this._store.__check__(e)}_clearGlobalState(e){if(null!=this._scheduled[e]){clearTimeout(this._scheduled[e].expiration);delete this._scheduled[e];return true}return false}_free(e,t,n,r){var i=this;return _asyncToGenerator((function*(){var t,s;try{var o=yield i._store.__free__(e,n.weight);s=o.running;i.Events.trigger("debug",`Freed ${n.id}`,r);if(0===s&&i.empty())return i.Events.trigger("idle")}catch(e){t=e;return i.Events.trigger("error",t)}}))()}_run(e,t,n){var r,i,s;t.doRun();r=this._clearGlobalState.bind(this,e);s=this._run.bind(this,e,t);i=this._free.bind(this,e,t);return this._scheduled[e]={timeout:setTimeout(()=>t.doExecute(this._limiter,r,s,i),n),expiration:null!=t.options.expiration?setTimeout((function(){return t.doExpire(r,s,i)}),n+t.options.expiration):void 0,job:t}}_drainOne(e){return this._registerLock.schedule(()=>{var t,n,r,i,s;if(0===this.queued())return this.Promise.resolve(null);s=this._queues.getFirst();var o=r=s.first();i=o.options;t=o.args;if(null!=e&&i.weight>e)return this.Promise.resolve(null);this.Events.trigger("debug",`Draining ${i.id}`,{args:t,options:i});n=this._randomIndex();return this._store.__register__(n,i.weight,i.expiration).then(({success:e,wait:o,reservoir:a})=>{var l;this.Events.trigger("debug",`Drained ${i.id}`,{success:e,args:t,options:i});if(e){s.shift();l=this.empty();l&&this.Events.trigger("empty");0===a&&this.Events.trigger("depleted",l);this._run(n,r,o);return this.Promise.resolve(i.weight)}return this.Promise.resolve(null)})})}_drainAll(e,t=0){return this._drainOne(e).then(n=>{var r;if(null!=n){r=null!=e?e-n:e;return this._drainAll(r,t+n)}return this.Promise.resolve(t)}).catch(e=>this.Events.trigger("error",e))}_dropAllQueued(e){return this._queues.shiftAll((function(t){return t.doDrop({message:e})}))}stop(e={}){var t,n;e=u.load(e,this.stopDefaults);n=e=>{var t;t=()=>{var t;t=this._states.counts;return t[0]+t[1]+t[2]+t[3]===e};return new this.Promise((e,n)=>t()?e():this.on("done",()=>{if(t()){this.removeAllListeners("done");return e()}}))};t=e.dropWaitingJobs?(this._run=function(t,n){return n.doDrop({message:e.dropErrorMessage})},this._drainOne=()=>this.Promise.resolve(null),this._registerLock.schedule(()=>this._submitLock.schedule(()=>{var t,r,i;r=this._scheduled;for(t in r){i=r[t];if("RUNNING"===this.jobStatus(i.job.options.id)){clearTimeout(i.timeout);clearTimeout(i.expiration);i.job.doDrop({message:e.dropErrorMessage})}}this._dropAllQueued(e.dropErrorMessage);return n(0)}))):this.schedule({priority:s-1,weight:0},()=>n(1));this._receive=function(t){return t._reject(new Bottleneck.prototype.BottleneckError(e.enqueueErrorMessage))};this.stop=()=>this.Promise.reject(new Bottleneck.prototype.BottleneckError("stop() has already been called"));return t}_addToQueue(e){var t=this;return _asyncToGenerator((function*(){var n,r,i,s,o,a,l;n=e.args;s=e.options;try{var c=yield t._store.__submit__(t.queued(),s.weight);o=c.reachedHWM;r=c.blocked;l=c.strategy}catch(r){i=r;t.Events.trigger("debug",`Could not queue ${s.id}`,{args:n,options:s,error:i});e.doDrop({error:i});return false}if(r){e.doDrop();return true}if(o){a=l===Bottleneck.prototype.strategy.LEAK?t._queues.shiftLastFrom(s.priority):l===Bottleneck.prototype.strategy.OVERFLOW_PRIORITY?t._queues.shiftLastFrom(s.priority+1):l===Bottleneck.prototype.strategy.OVERFLOW?e:void 0;null!=a&&a.doDrop();if(null==a||l===Bottleneck.prototype.strategy.OVERFLOW){null==a&&e.doDrop();return o}}e.doQueue(o,r);t._queues.push(e);yield t._drainAll();return o}))()}_receive(e){if(null!=this._states.jobStatus(e.options.id)){e._reject(new Bottleneck.prototype.BottleneckError(`A job with the same id already exists (id=${e.options.id})`));return false}e.doReceive();return this._submitLock.schedule(this._addToQueue,e)}submit(...e){var t,n,i,s,o,a,l;if("function"===typeof e[0]){var c,_,d,p;o=e,c=o,_=_toArray(c),n=_[0],e=_.slice(1),c,d=h.call(e,-1),p=_slicedToArray(d,1),t=p[0],d;s=u.load({},this.jobDefaults)}else{var v,y,f,m;a=e,v=a,y=_toArray(v),s=y[0],n=y[1],e=y.slice(2),v,f=h.call(e,-1),m=_slicedToArray(f,1),t=m[0],f;s=u.load(s,this.jobDefaults)}l=(...e)=>new this.Promise((function(t,r){return n(...e,(function(...e){return(null!=e[0]?r:t)(e)}))}));i=new r(l,e,s,this.jobDefaults,this.rejectOnDrop,this.Events,this._states,this.Promise);i.promise.then((function(e){return"function"===typeof t?t(...e):void 0})).catch((function(e){return Array.isArray(e)?"function"===typeof t?t(...e):void 0:"function"===typeof t?t(e):void 0}));return this._receive(i)}schedule(...e){var t,n,i;if("function"===typeof e[0]){var s=e;var o=_toArray(s);i=o[0];e=o.slice(1);n={}}else{var a=e;var l=_toArray(a);n=l[0];i=l[1];e=l.slice(2)}t=new r(i,e,n,this.jobDefaults,this.rejectOnDrop,this.Events,this._states,this.Promise);this._receive(t);return t.promise}wrap(e){var t,n;t=this.schedule.bind(this);n=function wrapped(...n){return t(e.bind(this),...n)};n.withOptions=function(n,...r){return t(n,e,...r)};return n}updateSettings(e={}){var t=this;return _asyncToGenerator((function*(){yield t._store.__updateSettings__(u.overwrite(e,t.storeDefaults));u.overwrite(e,t.instanceDefaults,t);return t}))()}currentReservoir(){return this._store.__currentReservoir__()}incrementReservoir(e=0){return this._store.__incrementReservoir__(e)}}Bottleneck.default=Bottleneck;Bottleneck.Events=n;Bottleneck.version=Bottleneck.prototype.version=_version.version;Bottleneck.strategy=Bottleneck.prototype.strategy={LEAK:1,OVERFLOW:2,OVERFLOW_PRIORITY:4,BLOCK:3};Bottleneck.BottleneckError=Bottleneck.prototype.BottleneckError=dew$4();Bottleneck.Group=Bottleneck.prototype.Group=dew$d();Bottleneck.RedisConnection=Bottleneck.prototype.RedisConnection=dew$8();Bottleneck.IORedisConnection=Bottleneck.prototype.IORedisConnection=dew$9();Bottleneck.Batcher=Bottleneck.prototype.Batcher=dew$e();Bottleneck.prototype.jobDefaults={priority:t,weight:1,expiration:null,id:"<no-id>"};Bottleneck.prototype.storeDefaults={maxConcurrent:null,minTime:0,highWater:null,strategy:Bottleneck.prototype.strategy.LEAK,penalty:null,reservoir:null,reservoirRefreshInterval:null,reservoirRefreshAmount:null,reservoirIncreaseInterval:null,reservoirIncreaseAmount:null,reservoirIncreaseMaximum:null};Bottleneck.prototype.localStoreDefaults={Promise:Promise,timeout:null,heartbeatInterval:250};Bottleneck.prototype.redisStoreDefaults={Promise:Promise,timeout:null,heartbeatInterval:5e3,clientTimeout:1e4,Redis:null,clientOptions:{},clusterNodes:null,clearDatastore:false,connection:null};Bottleneck.prototype.instanceDefaults={datastore:"local",connection:null,id:"<no-id>",rejectOnDrop:true,trackDoneStatus:false,Promise:Promise};Bottleneck.prototype.stopDefaults={enqueueErrorMessage:"This limiter has been stopped and cannot accept new jobs.",dropWaitingJobs:true,dropErrorMessage:"This limiter has been stopped."};return Bottleneck}.call(void 0);exports$f=e;return exports$f}var exports$g={},_dewExec$g=false;function dew$g(){if(_dewExec$g)return exports$g;_dewExec$g=true;exports$g=dew$f();return exports$g}var index=dew$g();export default index;export{dew$g as __dew};

